#dotfiles git (rather than dfr (dotfiles repo) which is too close to drf (docker run fast.)) also deathfire grasp.

alias dfg='git --git-dir=$HOME/.dotfiles-repo/ --work-tree=$HOME'


dfgfixsym() {
	# fix symlinks for dotfiles
	local filepath
	dfg ls-tree -r --name-only --full-tree HEAD | while read filepath; do
		#Check input file is a symlink
		if [[ -L "$filepath" ]]; then
			local symlink="$filepath"
			local target="$(readlink "$symlink")"
			#if the symlink goes inside the home directory; make it relative.
			if [[ "$target" == /home/* ]]; then
				#ln -srf $target $symlink #actually skips intermediate symlinks when -r option is given; not an acceptable solution.
				echo "Fixing: $symlink"
				local targetname="$(basename "$target")"
				local targetdir="${target%$targetname}"
				local symlinkname="$(basename "$symlink")"
				local symlinkdir="${symlink%$symlinkname}"
				local reltargetdir="$(realpath --relative-to="$symlinkdir" "$targetdir")"
				local reltarget="$reltargetdir"/"$targetname"
				ln -sf "$reltarget" "$symlink"
			elif [[ "$target" == /* ]]; then
				echo "Found non-relative symlink in dotfiles:"
				ls -l "$symlink"
			fi
		fi
	done
}


alias dfgk='dfg remote set-url origin git@github.com:Patricol/dotfiles.git && add_ssh_keys github'

alias dfgs='dfg status --ahead-behind'

alias dfgd='dfg diff'
alias dfgdc='dfgd --cached'

#provide the branch to pull changes from as an arg
alias dfgdt='dfg difftool -y -t meld'
alias dfgdtm='dfgdt master'
alias dfgdtp='dfgdt archpatricol'
alias dfgdtw='dfgdt archwork'
alias dfgdtda='dfgdt dockerarch'
alias dfgdtdu='dfgdt dockerubuntu'

alias dfgmt='dfg mergetool -t meld'


getnewcommits() {
	declare branch="$1"
	local merge_base="$(dfg merge-base -a "$branch" master)"
	#need ancestry path so it doesn't include previous one-way merges.
	dfg rev-list --ancestry-path "$merge_base".."$branch"
}

dfghum() {
	declare branch="$1"
	local commitcount="$(getnewcommits "$branch" | wc -l)"
	if [[ "$commitcount" -ge 2 ]]; then
		true
		return "$?"
	else
		echo "$branch has no unmerged changes."
		false
		return "$?"
	fi
}
alias dfghump='dfghum archpatricol'
alias dfghumw='dfghum archwork'
alias dfghumda='dfghum dockerarch'
alias dfghumdu='dfghum dockerubuntu'

#find merge commit
dfgfmc() {
	declare branch="$1"
	getnewcommits "$branch" | tail -n 1
}

# ours-merge merge commit
dfgommc() {
	declare branch="$1"
	local merge_commit="$(dfgfmc "$branch")"
	local message="fake merge to avoid pulling in branch-specific differences"
	dfg merge -s ours -m "$message" --no-edit "$merge_commit" 
}
alias dfgommcp='dfgommc archpatricol'
alias dfgommcw='dfgommc archwork'
alias dfgommcda='dfgommc dockerarch'
alias dfgommcdu='dfgommc dockerubuntu'


alias dfgmac='dfg merge --edit --no-ff'
alias dfgm='dfgmac --no-commit'
alias dfgmacm='dfgmac master'
alias dfgmm='dfgm master'
alias dfgmp='dfgm archpatricol'
alias dfgmw='dfgm archwork'
alias dfgmda='dfgm dockerarch'
alias dfgmdu='dfgm dockerubuntu'

alias dfga='dfg add'
alias dfgaa='dfgfixsym && dfga -u && dfga ~/.themes ~/.aliases ~/.config/wpg ~/.config/systemd ~/.config/powerline ~/.config/wallpapers ~/.config/qt5ct/'
alias dfgaae='dfgaa && dfg reset HEAD -- ~/.config/htop/htoprc'
alias dfgc='dfg commit -v'
alias dfgac='dfgaa && dfgc'

alias dfgch='dfg checkout'
alias dfgchm='dfgch master'
alias dfgchp='dfgch archpatricol'
alias dfgchw='dfgch archwork'
alias dfgchda='dfgch dockerarch'
alias dfgchdu='dfgch dockerubuntu'

alias dfgpop='dfg stash pop'
alias dfgpopall='while dfgpop; do :; done'

alias dfgp='dfgk && dfg push'

#to avoid merging branch-specific changes back into master; use "dfg merge -s ours BRANCH" when the BRANCH is only ahead by its merge commit.

dfgcmctm() {
	declare branch="$1"
	local commit_message="dummy commit to enable the next merge"
	local merge_message="merge again to re-add branch-specific differences"
	#commit merge changes to master
	#dfg stash
	#dfgpop
	#dfga -u
	#dfg reset --soft HEAD~1
	dfgc --no-edit
	dfgc --allow-empty -m "$commit_message"
	dfgch "$branch"
	dfg merge -s ours -m "$merge_message" --no-edit master
	echo "sanity-check the changes made to both branches, then push."
}
alias dfgcmctmp='dfgcmctm archpatricol'
alias dfgcmctmw='dfgcmctm archwork'
alias dfgcmctmda='dfgcmctm dockerarch'
alias dfgcmctmdu='dfgcmctm dockerubuntu'

dfgcheckuptodate() {
	declare branch="$1"
	dfgch "$branch"
	dfgmm
	echo "MERGING NEW THINGS FROM MASTER INTO $branch"
	dfg merge HEAD || dfgmt && dfgc
	dfg merge HEAD # will error out if merge is in progress; if commit was aborted or otherwise failed because of merge conflicts
}

dfgmtmf() {
	#merge to master from ... (P.S.: do not remove the stash and pop; that allows the soft reset; which is otherwise blocked by git as it detects the ongoing merge.)
	declare branch="$1"
	if dfgcheckuptodate "$branch"; then
		dfgchm
		((dfghum "$branch" && dfgommc "$branch" && (dfgm "$branch" ; dfgmt ; dfgwarnmerge)) || true )
		if dfghum "$branch"; then
			dfgommc "$branch"
			dfgm "$branch" || (dfgmt &)
			echo "MERGING NEW THINGS FROM $branch INTO MASTER"
			echo "CHECK CHANGES ARE GOOD, THEN MUST USE dfgcmctm $branch TO COMMIT OR OTHERWISE WRAP UP!"
			false
			return "$?"
		else
			true
			return "$?"
		fi
	else
		false
		return "$?"
	fi
}
alias dfgmtmfp='dfgmtmf archpatricol'
alias dfgmtmfw='dfgmtmf archwork'
alias dfgmtmfda='dfgmtmf dockerarch'
alias dfgmtmfdu='dfgmtmf dockerubuntu'

alias dfgfullmerge='dfgmtmfp && dfgmtmfw && dfgmtmfda && dfgmtmfdu && dfgchp'
alias dfgmergeall='dfgfullmerge'

alias dfgpopush='dfgpopall && dfgs && dfgp'
alias dfgpushall='dfgchm && dfgpopush && dfgchdu && dfgpopush && dfgchda && dfgpopush && dfgchw && dfgpopush && dfgchp && dfgpopush'

alias gsf='sudo git --git-dir=/root/.systemfiles-repo/ --work-tree=/'

