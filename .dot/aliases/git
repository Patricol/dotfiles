# vi:syntax=sh
# systemfiles and dotfiles git (rather than dfr (dotfiles repo) which is too close to drf (docker run fast.)) also deathfire grasp.
# dfg_* are intended for internal use only.

dfg_git_dir="${HOME}/.dotfiles-repo"
dfg_work_tree="${HOME}"
alias dfg='git --git-dir=${dfg_git_dir} --work-tree=${dfg_work_tree}'


dfgfixsym() {
	# fix symlinks for dotfiles
	local filepath symlink target #declaring symlink and target here makes zsh less verbose
	dfg ls-tree -r --name-only --full-tree HEAD | while read filepath; do
		#Check input file is a symlink
		filepath="${HOME}/${filepath}"
		if [[ -L "${filepath}" ]]; then
			symlink="${filepath}"
			target="$(readlink "${symlink}")"
			#if the symlink goes inside the home directory; make it relative.
			if [[ "${target}" == /home/* ]]; then
				#ln -srf "${target}" "${symlink}" #actually skips intermediate symlinks when -r option is given; not an acceptable solution.
				echo "Fixing: ${symlink}"
				local targetname
				targetname="$(basename "${target}")"
				local targetdir
				targetdir="${target%${targetname}}"
				local symlinkname
				symlinkname="$(basename "${symlink}")"
				local symlinkdir
				symlinkdir="${symlink%${symlinkname}}"
				local reltargetdir
				reltargetdir="$(realpath --relative-to="${symlinkdir}" "${targetdir}")"
				local reltarget
				reltarget="${reltargetdir}"/"${targetname}"
				ln -sf "${reltarget}" "${symlink}"
			elif [[ "${target}" == /* ]]; then
				echo "Found non-relative symlink in dotfiles:"
				ls -l "${symlink}"
			fi
		fi
	done
}

colormsg_yellow() {
	echo -e "\033[0;33m$@\033[0m" >&2
}
colormsg_light_magenta() {
	echo -e "\033[1;35m$@\033[0m" >&2
}

alias dfgk='dfg remote set-url origin git@github.com:Patricol/dotfiles.git && add_ssh_keys github'

alias dfgs='dfg status --ahead-behind'
alias dfgl='dfg log --relative-date --graph'
alias dfglc='dfgl --pretty=format:"%Cgreen%h%x09%Cred%ad%x09%Creset%s%Cblue%d"'

alias dfgd='dfg diff'
alias dfgdc='dfgd --cached'

#provide the branch to pull changes from as an arg
alias dfgdt='dfg difftool -d -y -t meld'
alias dfgdtm='dfgdt master'
alias dfgdtp='dfgdt archpatricol'
alias dfgdtw='dfgdt archwork'
alias dfgdtda='dfgdt dockerarch'
alias dfgdtdu='dfgdt dockerubuntu'

alias dfgmt='dfg mergetool -t meld'


dfg_getmsg_mbsd() {
	declare branch="$1"
	[[ -n "${branch}" ]] || return 4
	# get message for merging branch-specific differences. should avoid changing it, as it breaks automatic merging.
	echo "merge ${branch} again to re-add branch-specific differences"
}

dfg_getc_mim() {
	# last time changes from this branch were merged into master
	local lmim
	lmim=$(dfg rev-list --merges --grep="Merge branch '${branch}'" "${branch}" | tac | tail -n1)
	echo "${lmim}"
}
dfg_getc_mbsdfm() {
	#find 'merge branch-specific differences from master' commit (last time they were re-merged into a non-master branch using -s ours etc.)
	declare branch="$1"
	local msgfmbsd
	msgfmbsd="$(dfg_getmsg_mbsd ${branch})"
	local lmsgfmbsd # last time branch-specific changes were merged into this branch after changes from this branch were merged into master
	lmsgfmbsd=$(dfg rev-list --merges --grep="${msgfmbsd}" "${branch}" | tac | tail -n1)
	echo "${lmsgfmbsd}"
}
dfg_getc_mfm() {
	# last time changes from master were merged into this branch
	declare branch="$1"
	local lmfm
	lmfm=$(dfg rev-list --merges --grep="Merge branch 'master' into ${branch}" "${branch}" | tac | tail -n1)
	echo "${lmfm}"
}

dfg_getc_new() {
	# get new commits (ones that originated in this branch and haven't been merged into master yet)
	declare branch="$1"
	dfg rev-list --no-merges --first-parent "$(dfg_getc_mbsdfm ${branch})..${branch}"
}

dfg_hum() {
	declare branch="$1"
	if [[ "$(dfg_getc_new "${branch}" | wc -l)" -ge 1 ]]; then
		echo "${branch} has unmerged changes."
		true
		return "$?"
	else
		echo "${branch} has no unmerged changes." >&2
		false
		return "$?"
	fi
}


dfg_ommc() {
	# ours-merge merge commit
	declare branch="$1"
	local mbsdfmc
	mbsdfmc="$(dfg_getc_mbsdfm "${branch}")"
	[[ -n "${mbsdfmc}" ]] || return 5
	local message
	message="ours-merge to avoid pulling in branch-specific differences"
	dfg merge -s ours -m "${message}" --no-edit "${mbsdfmc}" 
}


alias dfg_m='dfg merge --edit --no-ff --no-commit'
alias dfg_mm='dfg_m master'

alias dfga='dfg add'

dfgaa() {
	dfgfixsym
	dfga -u
     	for directory in ~/.{themes,dot} ~/.config/{custom/{wallpapers,watch},feh,fontconfig,i3,kitty,mpv,neofetch,polybar,powerline,qt5ct,rofi,systemd,wal,wpg}; do
		if [[ -d "${directory}" ]]; then
     			dfga "${directory}"
		else
			echo "skipping missing dir (${directory})"
		fi
	done
     	for directory in ~/.config/htop; do
		if [[ -d "${directory}" ]]; then
     			dfg reset HEAD -- "${directory}"
		fi
	done
}
alias dfgchhtop='dfgch -- ~/.config/htop/htoprc'
alias dfgc='dfg commit -v'
alias dfgac='dfgaa && dfgc'

alias dfgch='dfg checkout'
alias dfg_chm='dfgch master --'
alias dfgchp='dfgch archpatricol --'
alias dfgchw='dfgch archwork --'
alias dfgchda='dfgch dockerarch --'
alias dfgchdu='dfgch dockerubuntu --'

alias dfgpop='dfg stash pop'
alias dfgpopall='while dfgpop; do :; done'

alias dfgp='dfgk && dfg push'

alias dfgpopush='dfgpopall && dfgs && dfgp'


dfg_lock_branchdiffs() {
	# merge -s ours each branch, to lock in its differences from the master branch; so they don't need to be reapplied during the next merge. For example, customizations made while merging other branches' changes from master will be locked in by this.
	dfg_chm || exit 1
	dfgc --allow-empty -m "dummy commit to enable the next merges"
	
	local branch
	for branch in archpatricol archwork dockerarch dockerubuntu; do
		dfgch "${branch}" -- || exit 1
		dfg merge -s ours -m "$(dfg_getmsg_mbsd ${branch})" --no-edit master
	done
	dfgchp || exit 1
}


dfg_mfmt() {
	# merge from master to branch
	declare branch="$1"
	dfgch "${branch}" -- || exit 1
	dfg_mm
	colormsg_yellow "MERGING NEW THINGS FROM master INTO ${branch}; MAKE CHANGES AS NEEDED AND COMMIT."
	dfg merge HEAD || dfgmt && dfgc
	dfg merge HEAD # will error out if merge is in progress; if commit was aborted or otherwise failed because of merge conflicts
}

dfg_mtmf() {
	# merge to master from branch
	declare branch="$1"
	if dfg_mfmt "${branch}"; then
		dfg_chm
		if dfg_hum "${branch}"; then
			dfg_ommc "${branch}" || return "$?"
			colormsg_yellow "MERGING NEW THINGS FROM $branch INTO master."
			dfg_m "${branch}" || dfgmt
			colormsg_light_magenta "CHECK CHANGES ARE GOOD, THEN MUST USE dfgcmtm TO COMMIT AND WRAP UP!" >&2
			false
			return "$?"
		else
			true
			return "$?"
		fi
	else
		false
		return "$?"
	fi
}

alias dfgpull='dfgk && dfg pull'
alias dfgpullall='dfgk && dfgchp && dfg pull && dfgchw && dfg pull && dfgchda && dfg pull && dfgchdu && dfg pull && dfg_chm && dfg pull && dfgchp'

alias dfg_fullmerge_nopull='dfg_mtmf archpatricol && dfg_mtmf archwork && dfg_mtmf dockerarch && dfg_mtmf dockerubuntu && dfgchp'
alias dfgfullmerge='dfgpullall && dfg_fullmerge_nopull'
alias dfgfm='dfgfullmerge'
alias dfgfullmerge_and_lock='dfgfullmerge && dfg_lock_branchdiffs'
alias dfgfmal='dfgfullmerge_and_lock'

alias dfgpushall='dfgk && dfg_chm && dfgpopush && dfgchdu && dfgpopush && dfgchda && dfgpopush && dfgchw && dfgpopush && dfgchp && dfgpopush'

alias dfg_goback='dfg reset --hard HEAD~1 && dfgs'

dfgcmtm() {
	#continue merge to master
	dfg merge HEAD &> /dev/null && return 3
	local branch
	branch="$(cat "${dfg_git_dir}/MERGE_MSG" | sed -E "s/(Merge branch )?'//g")"
	dfgc --no-edit
	dfgc --allow-empty -m "dummy commit to enable the next merge"
	dfgch "${branch}" --
	dfg merge -s ours -m "$(dfg_getmsg_mbsd ${branch})" --no-edit master
	dfg_fullmerge_nopull
}


alias gsf='sudo GIT_EDITOR="svim" git --git-dir=/root/systemfiles-repo/ --work-tree=/'

alias gsfk='gsf remote set-url origin git@github.com:Patricol/systemfiles.git'

alias gsfs='gsf status --ahead-behind'

alias gsfd='gsf diff'
alias gsfdc='gsfd --cached'

alias gsfa='gsf add'
gsfaa() {
	gsfa -u
     	for directory in /root/{.dot,info,efivars} /boot/loader /boot/EFI/refind/{drivers*,theme} /usr/local/{bin,sbin} /etc/pacman.d/hooks; do
		if sudo test -d "${directory}"; then
     			gsfa "${directory}"
		else
			echo "skipping missing dir (${directory})"
		fi
	done
}
alias gsfaae='gsfaa && gsf reset HEAD -- /root/.dot/htoprc'
alias gsfc='gsf commit -v'
alias gsfac='gsfaa && gsfc'

gsf_push() {
	gsfk
	local gsf_command
	gsf_command="$(aecho gsf)"
	gsf_command="${gsf_command:5}" # need to remove sudo from the start
	local full_command
	full_command="add_ssh_keys /home/patricol/.ssh/github && ${gsf_command} push"
	sudo -i bash -ic -- "${full_command}"
}

alias gsfp='gsf_push'


