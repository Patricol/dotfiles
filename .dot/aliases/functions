# vi:syntax=sh
# Standalone functions that don't fit into the other sections.


add_ssh_keys() {
        eval "$(keychain --eval --quiet $@)"
}


extract() {
	# should probably not use 7z for all. e.g. extracting tar as root with 7z doesn't preserve permissions and ownership, but doing so with tar -xvzf does.
	# if the format is like .tar.gz, it'll give you a tar file. maybe handle that here. also maybe have it always extract into a new folder sharing the name of the archive. and ask before overwriting; and other similar options.
	# it also does that for .tgz. should just list the contents, and if the archive contains one single tar file, run different command.
	# anything handled by the tar command, do with tar. everything else goes through 7z; which lets me benefit from wide compatibility while using the most up-to-date kernel stuff for tar-related archives, which are the most critical and likely what I should standardize on.
	declare archives="$@"
	if [[ -z "${archives}" ]]; then
		echo "provide archive(s)" >&2
		false
		return "$?"
	fi
	local archive
	for archive in ${archives}; do
		if [[ ! -f "${archive}" ]]; then
			echo "given archive (${archive}) does not exist" >&2
			false
			return "$?"
		fi
		case "${archive%,}" in
			*.tar|*.tgz|*.tar.gz|*.txz|*.tar.xz|*.tbz2|*.tar.bz2)
				tar -xvf "${archive}"
				;;
			*.rar|*.cbr)
				unrar x "${archive}"
				;;
			*.lzma)
				unlzma "${archive}"
				;;
			*.bz2)
				bunzip2 "${archive}"
				;;
			*.gz)
				gunzip "${archive}"
				;;
			*.zip|*.cbz)
				unzip "${archive}"
				;;
			*.z)
				uncompress "${archive}"
				;;
			*.xz)
				unxz "${archive}"
				;;
			*.exe)
				cabextract "${archive}"
				;;
			*)
				7z x "${archive}"
				;;
		esac
	done
}

maketxz() {
	# txz is best for compression, efficiency etc. seems to be more resistant to corruption than gzip.
	if [[ "$#" -ne 1 ]]; then
	    echo "provide only a single folder or file as an argument" >&2
	    return 1
	fi
	declare target="$1"
	tar --create --verbose --auto-compress --file="${target}.txz" "${target}"
}

#makezip() {
	# extracting individual files from zip is faster. zip is also more ubiquitous.
#}

alias bal='vim -O ~/.dot/l/aliases/*'
alias brc='vim -O ~/.dot/l/shrc/*'


declare -A __edit_file_dict
declare -a __edit_file_completions

__make_file_dict() {
    __edit_file_dict=()
    __edit_file_completions=()

    # reduce the number of functions by making them handle arguments etc.

    add_name_for_file() {
	declare nickname="$1" ; shift
	declare filepath="$@"
	if [[ -L "${filepath}" ]]; then
	    filepath="$(readlink -f "${filepath}")"
	fi
	if [[ -d "${filepath}" ]]; then
	    local echo_dirs
	    if [[ -n "${echo_dirs}" ]]; then
		echo "Skipping directory: ${filepath}"
	    fi
	else
	    __edit_file_dict[${nickname}]="${filepath}"
	    __edit_file_completions+=("${nickname}:${filepath}")
	fi
    }
    __add_file_with_prefix_and_without_suffix() {
        declare prefix="$1" ; shift
        declare suffix="$1" ; shift
        declare filepath="$@"
        local filename nickname
        #filename="$(basename "${filepath}")"
        filename="${filepath##*/}" # needed something faster than subshell etc.
        nickname="${prefix}${filename%${suffix}}"
	add_name_for_file "${nickname}" "${filepath}"
    }

    add_files_with_prefix_and_without_suffix() {
        declare prefix="$1" ; shift
        declare suffix="$1" ; shift
        for file in $(echo $@ | tr "\n" " "); do
            __add_file_with_prefix_and_without_suffix "${prefix}" "${suffix}" "${file}"
        done
    }

    add_found_files_with_prefix_and_without_suffix() {
        declare prefix="$1" ; shift
        declare suffix="$1" ; shift
        declare dir="$1" ; shift
	local findargs
	findargs=("-maxdepth" "1" "-mindepth" "1" "!" "-type" "d")
	add_files_with_prefix_and_without_suffix "${prefix}" "${suffix}" "$(find ${dir} ${findargs[@]} $@ 2> /dev/null)"
    }

    add_files_without_suffix() {
        declare suffix="$1" ; shift
        add_files_with_prefix_and_without_suffix "" "${suffix}" $@
    }

    add_found_files_without_suffix() {
        declare suffix="$1" ; shift
        add_found_files_with_prefix_and_without_suffix "" "${suffix}" $@
    }

    add_files_with_prefix() {
        declare prefix="$1" ; shift
        add_files_with_prefix_and_without_suffix "${prefix}" "" $@
    }

    add_found_files_with_prefix() {
        declare prefix="$1" ; shift
        add_found_files_with_prefix_and_without_suffix "${prefix}" "" $@
    }

    add_files() {
        add_files_with_prefix_and_without_suffix "" "" $@
    }

    add_found_files() {
        add_found_files_with_prefix_and_without_suffix "" "" $@
    }


    add_found_files ~/.dot/l/
    add_found_files ~/.dot/l/bin/
    add_found_files ~/.dot/l/aliases/
    add_found_files_with_prefix "aliases/" ~/.dot/l/aliases/
    add_found_files ~/.dot/l/shrc/
    add_found_files /usr/local/bin/
    add_found_files_with_prefix "bin/" /usr/local/bin/
    add_found_files /usr/local/sbin/
    add_found_files_with_prefix "sbin/" /usr/local/sbin/
    add_found_files_without_suffix ".base" ~/.config/wpg/templates/ -name "*.base"
    add_found_files_with_prefix_and_without_suffix "nemo-" ".nemo_action" ~/.local/share/nemo/actions/
    add_found_files_with_prefix "feh/" ~/.config/feh/
    add_found_files_with_prefix_and_without_suffix "mpv/" ".conf" ~/.config/mpv/
    add_found_files_with_prefix_and_without_suffix "neofetch/" ".conf" ~/.config/neofetch/
    add_found_files_with_prefix_and_without_suffix "nvim/" ".vim" ~/.config/nvim/
    add_found_files_with_prefix "systemd/user/" ~/.config/systemd/user/
    add_found_files_with_prefix "wal/" ~/.config/wal/colorschemes/both/
    add_found_files_with_prefix "vim-plugins/" ~/.dot/l/vim/plugin_config/

    add_files /etc/{bash.bash_logout,bash.bashrc,environment,fstab,motd,profile} ~/.config/wpg/wpg.conf
    add_files_without_suffix ".conf" /etc/lightdm/{lightdm,lightdm-webkit2-greeter,slick-greeter}.conf /etc/{makepkg,mkinitcpio,pacman,sudo}.conf ~/.config/{mpv/mpv,kitty/kitty,redshift,qt5ct/qt5ct,compton/compton}.conf
    add_files_without_suffix "_config" /etc/ssh/{sshd,ssh}_config
    add_files_without_suffix ".txt" /root/setup.txt
    add_files_without_suffix ".json" ~/.config/indicator-sound-switcher.json
    add_files_without_suffix ".list" ~/.config/mimeapps.list

    add_name_for_file "yay" "${HOME}/.config/yay/config.json"
    add_name_for_file "bat" "${HOME}/.config/bat/config"
    add_name_for_file "vim-plugins" "${HOME}/.dot/l/vim/plugins"
    add_name_for_file "vim" "${HOME}/.dot/l/vimrc"

    local key print_dict
    if [[ "${print_dict}" ]]; then
        for key in "${!__edit_file_dict[@]}"; do
                echo "${key} : ${__edit_file_dict[${key}]}"
        done
    fi
}

edit_file() {
    #make this warn if the file is not tracked by dotfiles or systemfiles?
	
    #merge bal and brc into this; accept folder names etc.
	
    declare editor="$1" ; shift
    declare filepaths=()

    if ! [[ -v __edit_file_dict[@] ]]; then
        __make_file_dict
    fi
    
    local file filepath
    for file in $@; do
        if [[ "${__edit_file_dict[${file}]+exists}" ]]; then
	    filepath="${__edit_file_dict[${file}]}"
	    if [[ -L "${filepath}" ]]; then
		# keep this here just in case it is removed in __make_file_dict.
		filepath="$(readlink -f "${filepath}")"
	    fi
	    echo "${filepath}"
            filepaths+=("${filepath}")
        else
            echo "${file} not found; add it to the (__make_file_dict) function. (vc general)" >&2
        fi
    done
    
    if [[ ${#filepaths[@]} -ne 0 ]]; then
        ${editor} ${filepaths[@]}
    fi
}

alias vimc='edit_file svim'
alias atomc='edit_file satom'

alias vc='vimc'
alias ac='atomc'



i3prop() {
    echo "Click a window to watch its properties."
    echo "Note that window_type value in i3 is one of: (normal|dialog|utility|toolbar|splash|menu|dropdown_menu|popup_menu|tooltip|notification)"
    echo ""
    xprop -spy _NET_WM_NAME WM_NAME WM_CLASS WM_WINDOW_ROLE _NET_WM_WINDOW_TYPE | sed -E \
	-e 's/^_NET_WM_NAME.*?= /title=/g' \
	-e 's/^WM_NAME.*?= /title(fallback)=/g' \
	-e 's/^WM_CLASS.*?= (".*?"), (".*?")$/instance=\1\nclass=\2/g' \
	-e 's/^WM_WINDOW_ROLE.*?= /window_role=/g' \
	-e 's/^_NET_WM_WINDOW_TYPE.*?= /window_type=/g' \
	-e 's/^window_type=_NET_WM_WINDOW_TYPE_/window_type=/g'
}


tif() {
	#test if statement
	if [[ $@ ]]; then
		echo "True"
	else
		echo "False"
	fi
}

ier() {
	#if exists, run.
	local program="$1"; shift
	local args="$@"
	if which "${program}" &> /dev/null; then
		${program} ${args}
	fi
}

alias i3env='i3-msg "exec env > ~/i3env"'

check() {
	declare program_name="$1"
	cat "$(which "${program_name}")"
}


chwp() {
	declare new_wp="$1"
	if [[ -n "${new_wp}" ]]; then
		ln -sf "../animated/${new_wp}" ~/.dot/l/wallpapers/default/animated
	else
		ls ~/.dot/l/wallpapers/animated/
	fi
}
alias cwp='chwp'
